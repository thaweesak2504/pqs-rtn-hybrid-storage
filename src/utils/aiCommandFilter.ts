/**
 * AI Command Filter - Advanced filtering and processing of AI-generated commands
 * 
 * This utility class provides comprehensive filtering and processing of commands
 * generated by AI systems, preventing problematic commands from causing terminal hanging.
 * 
 * Features:
 * - AI response parsing and command extraction
 * - Command validation and sanitization
 * - Risk assessment and categorization
 * - Pattern recognition and learning
 * - Batch processing capabilities
 * - Export and analytics
 */

import { CommandSanitizer, ValidationResult } from './commandSanitizer';

export interface FilteredCommands {
  original: string;
  extractedCommands: string[];
  processedCommands: ProcessedCommand[];
  safeCommands: ProcessedCommand[];
  unsafeCommands: ProcessedCommand[];
  statistics: CommandStatistics;
  processingTime: number;
  timestamp: Date;
}

export interface ProcessedCommand {
  id: string;
  original: string;
  sanitized: string;
  isSafe: boolean;
  issues: string[];
  hasEncodingIssues: boolean;
  commandType: CommandType;
  riskLevel: RiskLevel;
  confidence: number;
  suggestions: string[];
  estimatedExecutionTime: number;
}

export interface CommandStatistics {
  totalCommands: number;
  safeCommands: number;
  unsafeCommands: number;
  highRiskCommands: number;
  mediumRiskCommands: number;
  lowRiskCommands: number;
  safetyRate: number;
  categoryBreakdown: Record<CommandType, number>;
  riskLevelBreakdown: Record<RiskLevel, number>;
  encodingIssues: number;
  averageConfidence: number;
}

export interface AIResponseAnalysis {
  responseId: string;
  timestamp: Date;
  totalLength: number;
  commandCount: number;
  safeCommandCount: number;
  unsafeCommandCount: number;
  processingTime: number;
  qualityScore: number;
  recommendations: string[];
}

export interface CommandPattern {
  pattern: string;
  frequency: number;
  successRate: number;
  averageExecutionTime: number;
  lastUsed: Date;
  confidence: number;
}

export type CommandType = 
  | 'git' 
  | 'npm' 
  | 'yarn' 
  | 'node' 
  | 'navigation' 
  | 'listing' 
  | 'file_operation' 
  | 'deletion' 
  | 'process_management' 
  | 'build' 
  | 'test' 
  | 'other';

export type RiskLevel = 'low' | 'medium' | 'high' | 'critical';

export class AICommandFilter {
  private static readonly COMMAND_PATTERNS = [
    /^git\s+/,
    /^npm\s+/,
    /^yarn\s+/,
    /^node\s+/,
    /^cd\s+/,
    /^ls\s*/,
    /^dir\s*/,
    /^mkdir\s+/,
    /^rm\s+/,
    /^del\s+/,
    /^cp\s+/,
    /^mv\s+/,
    /^chmod\s+/,
    /^chown\s+/,
    /^ps\s*/,
    /^kill\s+/,
    /^taskkill\s+/,
    /^netstat\s*/,
    /^ping\s+/,
    /^curl\s+/,
    /^wget\s+/,
    /^tar\s+/,
    /^zip\s+/,
    /^unzip\s+/,
    /^grep\s+/,
    /^find\s+/,
    /^cat\s+/,
    /^echo\s+/,
    /^touch\s+/,
    /^chcp\s+/
  ];
  
  private static readonly COMMAND_INDICATORS = [
    '$', '>', 'PS ', 'C:\\', '/', '\\', '&&', '||', ';', '|'
  ];
  
  private static readonly DANGEROUS_PATTERNS = [
    /rm\s+-rf/,
    /del\s+\/s/,
    /taskkill\s+\/f/,
    /format\s+/,
    /shutdown\s+/,
    /reboot\s+/,
    /chmod\s+777/,
    /chown\s+-R/,
    /dd\s+if=/,
    /mkfs\s+/
  ];
  
  private static commandPatterns: Map<string, CommandPattern> = new Map();
  private static processingHistory: AIResponseAnalysis[] = [];
  private static readonly MAX_HISTORY = 1000;
  
  /**
   * Filter AI-generated commands from response text
   * 
   * @param aiResponse - The AI response text to filter
   * @param options - Filtering options
   * @returns Filtered commands with analysis
   */
  static filterAIOutput(
    aiResponse: string, 
    options: {
      extractCommands?: boolean;
      validateCommands?: boolean;
      sanitizeCommands?: boolean;
      assessRisk?: boolean;
      generateSuggestions?: boolean;
    } = {}
  ): FilteredCommands {
    const startTime = Date.now();
    const timestamp = new Date();
    
    const {
      extractCommands = true,
      validateCommands = true,
      sanitizeCommands = true,
      assessRisk = true,
      generateSuggestions = true
    } = options;
    
    // Step 1: Extract commands from AI response
    const extractedCommands = extractCommands ? this.extractCommands(aiResponse) : [aiResponse];
    
    // Step 2: Process each command
    const processedCommands = extractedCommands.map(command => 
      this.processCommand(command, {
        validate: validateCommands,
        sanitize: sanitizeCommands,
        assessRisk,
        generateSuggestions
      })
    );
    
    // Step 3: Categorize commands
    const safeCommands = processedCommands.filter(cmd => cmd.isSafe);
    const unsafeCommands = processedCommands.filter(cmd => !cmd.isSafe);
    
    // Step 4: Generate statistics
    const statistics = this.generateStatistics(processedCommands);
    
    // Step 5: Record processing time
    const processingTime = Date.now() - startTime;
    
    // Step 6: Store analysis
    this.recordAnalysis({
      responseId: this.generateId(),
      timestamp,
      totalLength: aiResponse.length,
      commandCount: extractedCommands.length,
      safeCommandCount: safeCommands.length,
      unsafeCommandCount: unsafeCommands.length,
      processingTime,
      qualityScore: this.calculateQualityScore(processedCommands),
      recommendations: this.generateRecommendations(processedCommands)
    });
    
    return {
      original: aiResponse,
      extractedCommands,
      processedCommands,
      safeCommands,
      unsafeCommands,
      statistics,
      processingTime,
      timestamp
    };
  }
  
  /**
   * Extract commands from AI response text
   * 
   * @param text - The text to extract commands from
   * @returns Array of extracted commands
   */
  private static extractCommands(text: string): string[] {
    const commands: string[] = [];
    
    // Split by lines and look for command patterns
    const lines = text.split('\n');
    
    for (const line of lines) {
      const trimmed = line.trim();
      
      // Skip empty lines
      if (!trimmed) continue;
      
      // Check if line looks like a command
      if (this.looksLikeCommand(trimmed)) {
        // Clean up the command (remove prompt indicators)
        const cleanCommand = this.cleanCommandLine(trimmed);
        if (cleanCommand) {
          commands.push(cleanCommand);
        }
      }
    }
    
    return commands;
  }
  
  /**
   * Check if text looks like a command
   * 
   * @param text - The text to check
   * @returns True if text looks like a command
   */
  private static looksLikeCommand(text: string): boolean {
    // Check for command patterns
    for (const pattern of this.COMMAND_PATTERNS) {
      if (pattern.test(text)) {
        return true;
      }
    }
    
    // Check for common command indicators
    return this.COMMAND_INDICATORS.some(indicator => text.startsWith(indicator));
  }
  
  /**
   * Clean command line by removing prompt indicators
   * 
   * @param line - The command line to clean
   * @returns Cleaned command
   */
  private static cleanCommandLine(line: string): string {
    // Remove common prompt indicators
    let cleaned = line
      .replace(/^\$+\s*/, '') // Remove $ prompts
      .replace(/^>\s*/, '') // Remove > prompts
      .replace(/^PS\s+[^>]*>\s*/, '') // Remove PowerShell prompts
      .replace(/^C:\\[^>]*>\s*/, '') // Remove Windows prompts
      .replace(/^[^>]*>\s*/, '') // Remove generic prompts
      .trim();
    
    // Remove code block markers
    cleaned = cleaned
      .replace(/^```\w*\s*/, '') // Remove opening code blocks
      .replace(/\s*```$/, '') // Remove closing code blocks
      .trim();
    
    return cleaned;
  }
  
  /**
   * Process individual command
   * 
   * @param command - The command to process
   * @param options - Processing options
   * @returns Processed command information
   */
  private static processCommand(
    command: string, 
    options: {
      validate?: boolean;
      sanitize?: boolean;
      assessRisk?: boolean;
      generateSuggestions?: boolean;
    } = {}
  ): ProcessedCommand {
    const {
      validate = true,
      sanitize = true,
      assessRisk = true,
      generateSuggestions = true
    } = options;
    
    const id = this.generateId();
    let sanitized = command;
    let validation: ValidationResult | null = null;
    let isSafe = true;
    let issues: string[] = [];
    let hasEncodingIssues = false;
    
    // Step 1: Sanitize command
    if (sanitize) {
      sanitized = CommandSanitizer.sanitize(command);
      hasEncodingIssues = CommandSanitizer.detectEncodingIssues(command);
    }
    
    // Step 2: Validate command
    if (validate) {
      validation = CommandSanitizer.validate(sanitized);
      isSafe = validation.isValid;
      issues = validation.issues;
    }
    
    // Step 3: Assess risk level
    const riskLevel = assessRisk ? this.assessRiskLevel(sanitized) : 'low';
    
    // Step 4: Detect command type
    const commandType = this.detectCommandType(sanitized);
    
    // Step 5: Calculate confidence
    const confidence = this.calculateConfidence(command, sanitized, validation);
    
    // Step 6: Generate suggestions
    const suggestions = generateSuggestions ? this.generateSuggestions(command, sanitized, issues) : [];
    
    // Step 7: Estimate execution time
    const estimatedExecutionTime = this.estimateExecutionTime(sanitized);
    
    return {
      id,
      original: command,
      sanitized,
      isSafe,
      issues,
      hasEncodingIssues,
      commandType,
      riskLevel,
      confidence,
      suggestions,
      estimatedExecutionTime
    };
  }
  
  /**
   * Detect command type
   * 
   * @param command - The command to analyze
   * @returns Command type
   */
  private static detectCommandType(command: string): CommandType {
    const cmd = command.toLowerCase();
    
    if (cmd.startsWith('git ')) return 'git';
    if (cmd.startsWith('npm ')) return 'npm';
    if (cmd.startsWith('yarn ')) return 'yarn';
    if (cmd.startsWith('node ')) return 'node';
    if (cmd.startsWith('cd ') || cmd.startsWith('pushd ') || cmd.startsWith('popd ')) return 'navigation';
    if (cmd.startsWith('ls') || cmd.startsWith('dir') || cmd.startsWith('pwd')) return 'listing';
    if (cmd.startsWith('mkdir ') || cmd.startsWith('touch ') || cmd.startsWith('cp ') || cmd.startsWith('mv ')) return 'file_operation';
    if (cmd.startsWith('rm ') || cmd.startsWith('del ')) return 'deletion';
    if (cmd.startsWith('taskkill ') || cmd.startsWith('kill ') || cmd.startsWith('ps ')) return 'process_management';
    if (cmd.includes('build') || cmd.includes('compile')) return 'build';
    if (cmd.includes('test') || cmd.includes('spec')) return 'test';
    
    return 'other';
  }
  
  /**
   * Assess risk level of command
   * 
   * @param command - The command to assess
   * @returns Risk level
   */
  private static assessRiskLevel(command: string): RiskLevel {
    const cmd = command.toLowerCase();
    
    // Check for dangerous patterns
    for (const pattern of this.DANGEROUS_PATTERNS) {
      if (pattern.test(cmd)) {
        return 'critical';
      }
    }
    
    // Check for high-risk commands
    if (cmd.includes('taskkill /f') || cmd.includes('del /s') || cmd.includes('chmod 777')) {
      return 'high';
    }
    
    // Check for medium-risk commands
    if (cmd.includes('git push') || cmd.includes('npm install') || cmd.includes('chmod')) {
      return 'medium';
    }
    
    return 'low';
  }
  
  /**
   * Calculate confidence score for command
   * 
   * @param original - Original command
   * @param sanitized - Sanitized command
   * @param validation - Validation result
   * @returns Confidence score (0-1)
   */
  private static calculateConfidence(
    original: string, 
    sanitized: string, 
    validation: ValidationResult | null
  ): number {
    let confidence = 1.0;
    
    // Reduce confidence for encoding issues
    if (CommandSanitizer.detectEncodingIssues(original)) {
      confidence -= 0.3;
    }
    
    // Reduce confidence for validation issues
    if (validation && !validation.isValid) {
      confidence -= 0.2 * validation.issues.length;
    }
    
    // Reduce confidence for significant changes
    const changeRatio = Math.abs(original.length - sanitized.length) / original.length;
    if (changeRatio > 0.1) {
      confidence -= 0.2;
    }
    
    // Increase confidence for known patterns
    const commandType = this.detectCommandType(sanitized);
    if (commandType !== 'other') {
      confidence += 0.1;
    }
    
    return Math.max(0, Math.min(1, confidence));
  }
  
  /**
   * Generate suggestions for command improvement
   * 
   * @param original - Original command
   * @param sanitized - Sanitized command
   * @param issues - Validation issues
   * @returns Array of suggestions
   */
  private static generateSuggestions(
    original: string, 
    sanitized: string, 
    issues: string[]
  ): string[] {
    const suggestions: string[] = [];
    
    // Suggest fixes for encoding issues
    if (CommandSanitizer.detectEncodingIssues(original)) {
      suggestions.push('Remove Thai characters from command');
      suggestions.push('Use clean ASCII characters only');
    }
    
    // Suggest fixes for validation issues
    if (issues.includes('Contains Thai characters')) {
      suggestions.push('Check for invisible Thai characters');
    }
    
    if (issues.includes('Contains invisible characters')) {
      suggestions.push('Remove invisible Unicode characters');
    }
    
    if (issues.includes('Contains control characters')) {
      suggestions.push('Remove control characters');
    }
    
    // Suggest command improvements
    const commandType = this.detectCommandType(sanitized);
    if (commandType === 'git') {
      suggestions.push('Verify git repository status before execution');
    }
    
    if (commandType === 'npm') {
      suggestions.push('Check package.json before installing');
    }
    
    if (commandType === 'deletion') {
      suggestions.push('Double-check file paths before deletion');
      suggestions.push('Consider using --dry-run flag if available');
    }
    
    return suggestions;
  }
  
  /**
   * Estimate execution time for command
   * 
   * @param command - The command to estimate
   * @returns Estimated execution time in milliseconds
   */
  private static estimateExecutionTime(command: string): number {
    const cmd = command.toLowerCase();
    
    // Base execution time
    let estimatedTime = 1000;
    
    // Adjust based on command type
    if (cmd.includes('git')) estimatedTime = 2000;
    if (cmd.includes('npm')) estimatedTime = 5000;
    if (cmd.includes('yarn')) estimatedTime = 3000;
    if (cmd.includes('build')) estimatedTime = 10000;
    if (cmd.includes('install')) estimatedTime = 15000;
    if (cmd.includes('test')) estimatedTime = 8000;
    if (cmd.includes('compile')) estimatedTime = 12000;
    
    // Adjust based on complexity
    if (cmd.includes('&&') || cmd.includes('||')) estimatedTime *= 1.5;
    if (cmd.includes('|')) estimatedTime *= 1.2;
    
    return estimatedTime;
  }
  
  /**
   * Generate statistics for processed commands
   * 
   * @param commands - Array of processed commands
   * @returns Command statistics
   */
  private static generateStatistics(commands: ProcessedCommand[]): CommandStatistics {
    const total = commands.length;
    const safe = commands.filter(c => c.isSafe).length;
    const unsafe = total - safe;
    const highRisk = commands.filter(c => c.riskLevel === 'high').length;
    const mediumRisk = commands.filter(c => c.riskLevel === 'medium').length;
    const lowRisk = commands.filter(c => c.riskLevel === 'low').length;
    const encodingIssues = commands.filter(c => c.hasEncodingIssues).length;
    const avgConfidence = commands.reduce((sum, c) => sum + c.confidence, 0) / total;
    
    // Category breakdown
    const categoryBreakdown: Record<CommandType, number> = {
      git: 0, npm: 0, yarn: 0, node: 0, navigation: 0, listing: 0,
      file_operation: 0, deletion: 0, process_management: 0, build: 0, test: 0, other: 0
    };
    
    commands.forEach(cmd => {
      categoryBreakdown[cmd.commandType]++;
    });
    
    // Risk level breakdown
    const riskLevelBreakdown: Record<RiskLevel, number> = {
      low: 0, medium: 0, high: 0, critical: 0
    };
    
    commands.forEach(cmd => {
      riskLevelBreakdown[cmd.riskLevel]++;
    });
    
    return {
      totalCommands: total,
      safeCommands: safe,
      unsafeCommands: unsafe,
      highRiskCommands: highRisk,
      mediumRiskCommands: mediumRisk,
      lowRiskCommands: lowRisk,
      safetyRate: total > 0 ? (safe / total) * 100 : 0,
      categoryBreakdown,
      riskLevelBreakdown,
      encodingIssues,
      averageConfidence: avgConfidence || 0
    };
  }
  
  /**
   * Calculate quality score for processed commands
   * 
   * @param commands - Array of processed commands
   * @returns Quality score (0-100)
   */
  private static calculateQualityScore(commands: ProcessedCommand[]): number {
    if (commands.length === 0) return 0;
    
    const safetyScore = (commands.filter(c => c.isSafe).length / commands.length) * 40;
    const confidenceScore = (commands.reduce((sum, c) => sum + c.confidence, 0) / commands.length) * 30;
    const encodingScore = (commands.filter(c => !c.hasEncodingIssues).length / commands.length) * 20;
    const riskScore = (commands.filter(c => c.riskLevel === 'low').length / commands.length) * 10;
    
    return Math.round(safetyScore + confidenceScore + encodingScore + riskScore);
  }
  
  /**
   * Generate recommendations for AI response
   * 
   * @param commands - Array of processed commands
   * @returns Array of recommendations
   */
  private static generateRecommendations(commands: ProcessedCommand[]): string[] {
    const recommendations: string[] = [];
    
    const unsafeCount = commands.filter(c => !c.isSafe).length;
    const encodingIssues = commands.filter(c => c.hasEncodingIssues).length;
    const highRiskCount = commands.filter(c => c.riskLevel === 'high' || c.riskLevel === 'critical').length;
    
    if (unsafeCount > 0) {
      recommendations.push(`Review ${unsafeCount} unsafe commands before execution`);
    }
    
    if (encodingIssues > 0) {
      recommendations.push(`Fix encoding issues in ${encodingIssues} commands`);
    }
    
    if (highRiskCount > 0) {
      recommendations.push(`Exercise caution with ${highRiskCount} high-risk commands`);
    }
    
    if (commands.length > 10) {
      recommendations.push('Consider breaking down into smaller command batches');
    }
    
    return recommendations;
  }
  
  /**
   * Record AI response analysis
   * 
   * @param analysis - Analysis to record
   */
  private static recordAnalysis(analysis: AIResponseAnalysis): void {
    this.processingHistory.unshift(analysis);
    
    // Keep only recent history
    if (this.processingHistory.length > this.MAX_HISTORY) {
      this.processingHistory = this.processingHistory.slice(0, this.MAX_HISTORY);
    }
  }
  
  /**
   * Get processing history
   * 
   * @param limit - Maximum number of results to return
   * @returns Array of processing history
   */
  static getProcessingHistory(limit: number = 10): AIResponseAnalysis[] {
    return this.processingHistory.slice(0, limit);
  }
  
  /**
   * Get processing statistics
   * 
   * @returns Processing statistics
   */
  static getProcessingStatistics(): {
    totalResponses: number;
    averageQualityScore: number;
    averageProcessingTime: number;
    totalCommands: number;
    averageCommandsPerResponse: number;
  } {
    const total = this.processingHistory.length;
    if (total === 0) {
      return {
        totalResponses: 0,
        averageQualityScore: 0,
        averageProcessingTime: 0,
        totalCommands: 0,
        averageCommandsPerResponse: 0
      };
    }
    
    const avgQualityScore = this.processingHistory.reduce((sum, h) => sum + h.qualityScore, 0) / total;
    const avgProcessingTime = this.processingHistory.reduce((sum, h) => sum + h.processingTime, 0) / total;
    const totalCommands = this.processingHistory.reduce((sum, h) => sum + h.commandCount, 0);
    const avgCommandsPerResponse = totalCommands / total;
    
    return {
      totalResponses: total,
      averageQualityScore: Math.round(avgQualityScore),
      averageProcessingTime: Math.round(avgProcessingTime),
      totalCommands,
      averageCommandsPerResponse: Math.round(avgCommandsPerResponse)
    };
  }
  
  /**
   * Export processing data
   * 
   * @param format - Export format
   * @returns Exported data
   */
  static exportProcessingData(format: 'json' | 'csv' = 'json'): string {
    if (format === 'csv') {
      const headers = [
        'Response ID', 'Timestamp', 'Total Length', 'Command Count', 'Safe Command Count',
        'Unsafe Command Count', 'Processing Time', 'Quality Score'
      ];
      
      const rows = this.processingHistory.map(analysis => [
        analysis.responseId,
        analysis.timestamp.toISOString(),
        analysis.totalLength.toString(),
        analysis.commandCount.toString(),
        analysis.safeCommandCount.toString(),
        analysis.unsafeCommandCount.toString(),
        analysis.processingTime.toString(),
        analysis.qualityScore.toString()
      ]);
      
      return [headers.join(','), ...rows.map(row => row.join(','))].join('\n');
    }
    
    return JSON.stringify(this.processingHistory, null, 2);
  }
  
  /**
   * Clear processing history
   */
  static clearProcessingHistory(): void {
    this.processingHistory = [];
  }
  
  /**
   * Generate unique ID
   * 
   * @returns Unique ID
   */
  private static generateId(): string {
    return `ai_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

// Export utility functions for easy use
export const filterAIOutput = AICommandFilter.filterAIOutput;
export const getProcessingHistory = AICommandFilter.getProcessingHistory;
export const getProcessingStatistics = AICommandFilter.getProcessingStatistics;
export const exportProcessingData = AICommandFilter.exportProcessingData;

// Export for testing
export const _internal = {
  COMMAND_PATTERNS: AICommandFilter['COMMAND_PATTERNS'],
  COMMAND_INDICATORS: AICommandFilter['COMMAND_INDICATORS'],
  DANGEROUS_PATTERNS: AICommandFilter['DANGEROUS_PATTERNS'],
  commandPatterns: AICommandFilter['commandPatterns'],
  processingHistory: AICommandFilter['processingHistory']
};
