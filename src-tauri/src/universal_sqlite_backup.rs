use std::fs;
use std::path::PathBuf;
use std::time::{SystemTime, UNIX_EPOCH};
use rusqlite::Connection;
use tauri::api::path::app_data_dir;
use tauri::Config;

// Universal SQLite backup that creates standard .db files
pub fn create_universal_sqlite_backup() -> Result<String, String> {
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();
    
    let backup_filename = format!("database_universal_{}.db", timestamp);
    let backup_path = get_backup_directory()?.join(&backup_filename);
    
    // Get source database path
    let source_db_path = get_database_path()?;
    
    // Direct file copy to preserve BLOB data
    fs::copy(&source_db_path, &backup_path)
        .map_err(|e| format!("Failed to copy database file: {}", e))?;
    
    Ok(format!("Universal SQLite backup created: {}", backup_filename))
}

// Create standard SQL dump that works with any SQLite
pub fn create_standard_sql_dump() -> Result<String, String> {
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();
    
    let dump_filename = format!("database_standard_{}.sql", timestamp);
    let dump_path = get_backup_directory()?.join(&dump_filename);
    
    // Get database connection
    let db_path = get_database_path()?;
    let conn = Connection::open(&db_path)
        .map_err(|e| format!("Failed to open database: {}", e))?;
    
    let mut sql_content = String::new();
    
    // Add header
    sql_content.push_str("-- SQLite Database Dump\n");
    sql_content.push_str("-- Generated by PQS RTN Tauri Application\n");
    sql_content.push_str(&format!("-- Timestamp: {}\n", timestamp));
    sql_content.push_str("-- This file is compatible with any SQLite database\n\n");
    
    // Get all tables
    let tables = get_table_list(&conn)?;
    
    for table in tables {
        // Get table schema
        let schema = get_table_schema(&conn, &table)?;
        sql_content.push_str(&format!("-- Table: {}\n", table));
        sql_content.push_str(&format!("{}\n\n", schema));
        
        // Get table data
        let data = get_table_data(&conn, &table)?;
        for row in data {
            sql_content.push_str(&format!("{}\n", row));
        }
        sql_content.push_str("\n");
    }
    
    // Write to file
    fs::write(&dump_path, sql_content)
        .map_err(|e| format!("Failed to write SQL dump: {}", e))?;
    
    Ok(format!("Standard SQL dump created: {}", dump_filename))
}

// Helper functions
fn get_backup_directory() -> Result<PathBuf, String> {
    let config = Config::default();
    let app_data = app_data_dir(&config)
        .ok_or("Failed to get app data directory")?;
    
    let backup_dir = app_data.join("pqs-rtn-hybrid-storage").join("backups");
    
    if !backup_dir.exists() {
        fs::create_dir_all(&backup_dir)
            .map_err(|e| format!("Failed to create backup directory: {}", e))?;
    }
    
    Ok(backup_dir)
}

fn get_database_path() -> Result<PathBuf, String> {
    let config = Config::default();
    let app_data = app_data_dir(&config)
        .ok_or("Failed to get app data directory")?;
    
    Ok(app_data.join("pqs-rtn-hybrid-storage").join("database.db"))
}

#[allow(dead_code)]
fn copy_database_schema(source: &Connection, backup: &Connection) -> Result<(), String> {
    // Get all CREATE TABLE statements
    let mut stmt = source.prepare("SELECT sql FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'")
        .map_err(|e| format!("Failed to prepare schema query: {}", e))?;
    
    let rows = stmt.query_map([], |row| {
        let sql: String = row.get(0)?;
        Ok(sql)
    }).map_err(|e| format!("Failed to query schema: {}", e))?;
    
    for row in rows {
        let sql = row.map_err(|e| format!("Failed to get schema row: {}", e))?;
        backup.execute(&sql, [])
            .map_err(|e| format!("Failed to execute schema: {}", e))?;
    }
    
    Ok(())
}

#[allow(dead_code)]
fn copy_database_data(source: &Connection, backup: &Connection) -> Result<(), String> {
    // Get all tables
    let tables = get_table_list(source)?;
    
    for table in tables {
        // Get table data
        let mut stmt = source.prepare(&format!("SELECT * FROM {}", table))
            .map_err(|e| format!("Failed to prepare data query for {}: {}", table, e))?;
        
        let rows = stmt.query_map([], |row| {
            let mut values = Vec::new();
            let mut i = 0;
            loop {
                // Try different data types
                if let Ok(value) = row.get::<_, String>(i) {
                    values.push(serde_json::Value::String(value));
                    i += 1;
                } else if let Ok(value) = row.get::<_, i64>(i) {
                    values.push(serde_json::Value::Number(serde_json::Number::from(value)));
                    i += 1;
                } else if let Ok(value) = row.get::<_, f64>(i) {
                    values.push(serde_json::Value::Number(serde_json::Number::from_f64(value).unwrap_or(serde_json::Number::from(0))));
                    i += 1;
                } else if let Ok(value) = row.get::<_, bool>(i) {
                    values.push(serde_json::Value::Bool(value));
                    i += 1;
                } else if let Ok(value) = row.get::<_, Vec<u8>>(i) {
                    // Convert BLOB to base64 string
                    use base64::{Engine as _, engine::general_purpose};
                    let base64_str = general_purpose::STANDARD.encode(value);
                    values.push(serde_json::Value::String(base64_str));
                    i += 1;
                } else {
                    // Try NULL
                    if let Ok(_) = row.get::<_, Option<String>>(i) {
                        values.push(serde_json::Value::Null);
                        i += 1;
                    } else {
                        break;
                    }
                }
            }
            Ok(values)
        }).map_err(|e| format!("Failed to query data for {}: {}", table, e))?;
        
        // Insert data into backup
        for row in rows {
            let values = row.map_err(|e| format!("Failed to get data row: {}", e))?;
            
            // Skip if no values
            if values.is_empty() {
                continue;
            }
            
            let placeholders = vec!["?"; values.len()].join(", ");
            let insert_sql = format!("INSERT INTO {} VALUES ({})", table, placeholders);
            
            let mut insert_stmt = backup.prepare(&insert_sql)
                .map_err(|e| format!("Failed to prepare insert for {}: {}", table, e))?;
            
            // Convert serde_json::Value to ToSql parameters
            let params: Vec<Box<dyn rusqlite::ToSql>> = values.into_iter().map(|v| {
                match v {
                    serde_json::Value::String(s) => Box::new(s) as Box<dyn rusqlite::ToSql>,
                    serde_json::Value::Number(n) => {
                        if let Some(i) = n.as_i64() {
                            Box::new(i) as Box<dyn rusqlite::ToSql>
                        } else if let Some(f) = n.as_f64() {
                            Box::new(f) as Box<dyn rusqlite::ToSql>
                        } else {
                            Box::new(n.to_string()) as Box<dyn rusqlite::ToSql>
                        }
                    },
                    serde_json::Value::Bool(b) => Box::new(b) as Box<dyn rusqlite::ToSql>,
                    serde_json::Value::Null => Box::new(Option::<String>::None) as Box<dyn rusqlite::ToSql>,
                    _ => Box::new(v.to_string()) as Box<dyn rusqlite::ToSql>,
                }
            }).collect();
            
            let param_refs: Vec<&dyn rusqlite::ToSql> = params.iter().map(|p| p.as_ref()).collect();
            insert_stmt.execute(param_refs.as_slice())
                .map_err(|e| format!("Failed to insert data for {}: {}", table, e))?;
        }
    }
    
    Ok(())
}

fn get_table_list(conn: &Connection) -> Result<Vec<String>, String> {
    let mut stmt = conn.prepare("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'")
        .map_err(|e| format!("Failed to prepare table list query: {}", e))?;
    
    let rows = stmt.query_map([], |row| {
        let name: String = row.get(0)?;
        Ok(name)
    }).map_err(|e| format!("Failed to query table list: {}", e))?;
    
    let mut tables = Vec::new();
    for row in rows {
        let name = row.map_err(|e| format!("Failed to get table name: {}", e))?;
        tables.push(name);
    }
    
    Ok(tables)
}

fn get_table_schema(conn: &Connection, table: &str) -> Result<String, String> {
    let schema: String = conn.query_row(
        "SELECT sql FROM sqlite_master WHERE type='table' AND name=?",
        [table],
        |row| row.get(0)
    ).map_err(|e| format!("Failed to get schema for {}: {}", table, e))?;
    
    Ok(schema)
}

fn get_table_data(conn: &Connection, table: &str) -> Result<Vec<String>, String> {
    let mut stmt = conn.prepare(&format!("SELECT * FROM {}", table))
        .map_err(|e| format!("Failed to prepare data query for {}: {}", table, e))?;
    
    let rows = stmt.query_map([], |row| {
        let mut values = Vec::new();
        let mut i = 0;
        loop {
            match row.get::<_, String>(i) {
                Ok(value) => {
                    values.push(value);
                    i += 1;
                },
                Err(_) => break,
            }
        }
        
        // Create INSERT statement
        let mut insert = format!("INSERT INTO {} VALUES (", table);
        
        for (i, value) in values.iter().enumerate() {
            if i > 0 { insert.push_str(", "); }
            if value == "NULL" {
                insert.push_str("NULL");
            } else {
                insert.push_str(&format!("'{}'", value.replace("'", "''")));
            }
        }
        insert.push_str(");");
        
        Ok(insert)
    }).map_err(|e| format!("Failed to query data for {}: {}", table, e))?;
    
    let mut data = Vec::new();
    for row in rows {
        let insert = row.map_err(|e| format!("Failed to get data row: {}", e))?;
        data.push(insert);
    }
    
    Ok(data)
}
